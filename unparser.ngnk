/
Copyright 2023 Chris Pearson

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.


######################
##  ngn/k unparser  ##
######################

v, n, vv (?), vn, nvn, nv, nn combos (any more?)
(';f;f)       composition
(';f)         each
(+;(+;1 2);3) LHS brackets
`a            variable
`a`b`c        namespaced variable (a.b.c)
,`a           symbol
,`a`b         symbol list
(4:; 1; 2)    make list
1 :'          LHS space required (disambiguate from 1: which is a verb)
1 f'          LHS space required (1f read as single unit)
a:[;1]        knows that : is a fn here, not assignment
(+:)#         wrap LHS in parens to force noun
+(#:)         wrap RHS in parens to force noun
(1)1          wrap LHS in parens to prevent becoming one list literal
(1 2)3        ^ see above
(`a)`a        ^ see above
(`a`a)`a      ^ see above

(a;b):.. => (:;(4:;`a;`b);..)  destructure assignment
a[`b]:.. => (:;(`a;`b);..)     nested assignment


TODO
resolve inline TODOs
unicode char eg (Îº):{y!x y}
simplify list reprs eg general list (1;2;3) => 1 2 3
should M[0] be a L call instead? (remove first param of M)
need different parse impl?:
- preserve whitespace
- preserve ; vs \n as separator
- comments ambiguous in parse tree eg (`p";hello/")~`p";/ hello"
\


\d unparser

EMPTY:*|`p"1+"
LIST:*`p"(1;1)"
noun:{|/(1=*&(|x)~\:EMPTY; 3<#x; LIST~**x; ~^`i`f`c`s`o?_@*x)}
composition:{(2<#x)&(')~*x}

/ All fns below return a list of strings

wrap:{(a;b):x; (,,a),y,,,b}
(rounds;squares):wrap@'("()";"[]")

sep:{,/@[(#i)#,,,x;&~i:2!!-1+2*#y;:;y]}
(semicolons;newlines):sep@'";\n"

L:{$[noun x; f x; rounds f x]}
R:{$[((x~*x)|~`w=@*x)&(EMPTY~x)|^`u`v?@x; f x; rounds f x]}
M:{[modassgt;y]
   $[composition y; rounds f y
     modassgt&`u=@y; ,$y  / don't remove colon for modified assignments
     `u=@y; ,-1_$y        / remove colon from monads if monadic call
     |/(EMPTY~$[2<#y; y 2; +]; `v=@y; `w=@*y; noun y); f y
     rounds f y]}

advarg:{[adv;x]
  left:$[composition x; rounds f x
        (`u=@x)&(')~adv; ,-1_$x  / +:' is +' if used as monad
        |/(`u=@x; `v=@x; `w=@*x; noun x); f x
        rounds f x]
  ,/(left;,$adv)}

monad:{$[(::)~*|x; M[0;*x],"[]"
         `w=@*x; advarg . x  / TODO what about (')', \\, etc?
         (`i`i~_@'x)|(`s`s~_@'*'x)&&/~{x~*x}'x; ,/(rounds;::)@'(M[0];R)@'x
         ,/(M[0];R)@'x]}@

mexpr:{f[*x],squares semicolons 1_f'x}
infix:{nestedassgt:(`s=@*x 1)&(`A=@x 1)&(:)~*x
       left:$[nestedassgt; mexpr; L]
       ,/(left;M[1];R)@'x 1 0 2}

f:{$[EMPTY~x; ,""
     ()~x; ,"()"
     ~^`i`f`c`o?_@x; ,`k x
     1=#x; $[^`S`A?@x; ,$x; ,`k@*x]
     (1<#x)&`S=@x; ,"."/$x
     2=#x; monad x
     LIST~*x; rounds semicolons @ o'1_x
     composition x; ,/(M[0];o)@'1_x
     EMPTY~*x; newlines@ {$[(::)~x;,"";f x]}'1_x
     noun x; mexpr x
     infix x]}

/ Insert spaces

addspaces:{
  classes:"n: a a"@"0:;A[a{"'{(*y;*|y;*x)}':x
  notassgt:^("aa:";"an:")?classes
  disamb:~^("n:";"aa";"na";"an";"nn")?1_'classes
  disamb&:notassgt
  disamb[&1&#x]:1
  " "/,/'(&disamb)_x}

/ Main entry point

unparse: addspaces f@


/ #############
/ ##  tests  ##
/ #############

/ TODO: make this autodetect if being run as main (vs import), and enable if main
test:{$[y~unparse `p x;;`0:"[FAIL] GOT ",(unparse `p x)," NEED ",y]}
roundtrip:{$[x~unparse `p x;; `0:"[FAIL] GOT ",(unparse `p x)," NEED ",x]}

/ uncomment following lines to disable tests:
/ test:{y;}
/ roundtrip:{}

/ pure data
roundtrip "12"
roundtrip "1 2"
roundtrip "0.0"
roundtrip "hi"
roundtrip "\"hi\""
roundtrip "`hi"
roundtrip "`hi`ho"
roundtrip@,"+"
roundtrip "+:"
roundtrip "+/"
roundtrip "+/'"
roundtrip "(\"hi\";1)"
roundtrip "::"
roundtrip "A1"

/ convenience literals
test["0."] "0.0"
test["1e-2"] "0.01"
test["1f"] "1.0"
test["1 1f"] "1.0 1.0"

/ assignments
roundtrip "a:1"
roundtrip "a1:2"
roundtrip "A1:2"
roundtrip "(a;b):1 2"
roundtrip "(a;(b;c)):(1;2 3)"
roundtrip "a+:1"
roundtrip "a[`b]:1"
roundtrip "a[`b;`c`d]:1"

/ applications
roundtrip "+1"
roundtrip "1+"
roundtrip "(12)34"
roundtrip "12 34"
roundtrip "a,b"
roundtrip "f x"
roundtrip "1+2+3"
roundtrip "(1+2)+3"
test["1+(2+3)"] "1+2+3"
roundtrip "1+(2+3)+4"
roundtrip "(1+2)3"
roundtrip "(1+2)'3"
roundtrip "(+1)+1"
roundtrip "+/1"
roundtrip "+/\\"
roundtrip "1+/"
roundtrip "(1+)/"
roundtrip "{x}"
roundtrip "++:"
roundtrip "++"
roundtrip "+(+:)"
roundtrip "+(+)"
roundtrip "f[1;2]"
test["+[1;2]"] "1+2"
roundtrip "(+/1 2)3"
roundtrip "((+/'1 2)3)4"
roundtrip "a+'b"
roundtrip "f[;]"
test["+[a;]";"a+"]
roundtrip "+[;a]"
roundtrip "@[a;1;b]"
roundtrip "@[a;1;:;b]"
roundtrip "(1+2;3)"
roundtrip "(1)1"
roundtrip "(1 2)3"
roundtrip "(`a)`a"
roundtrip "(`a`b)`c"
roundtrip "(`a)`b`c"
roundtrip "`a`b 1"
roundtrip "+:/"
roundtrip "1+:/"
roundtrip "p+:/"
roundtrip "$[a;1;2;3;4]"
roundtrip "1 f'2"
test["(++)2";"(++:)2"]  / TODO: is this right?
roundtrip "f'[a;b;c]"
roundtrip "1 :/"
roundtrip "(1+2)#"
roundtrip "(+:)#"
roundtrip ":[;a]#"
test["((1+2)+(3+4))#"] "((1+2)+3+4)#"
test["(1 2)f'"] "1 2 f'"
roundtrip "3/1 2 3"
roundtrip "1:`hello"
roundtrip "~(+/)"
roundtrip "A1 2"
roundtrip "a.b"
roundtrip "a.b.c+1"
roundtrip "{x}[]"
roundtrip "()"

/ multi-line
test["a:1;";"a:1\n"]
test["a:1;b:2";"a:1\nb:2"]
test["a:1\nb:2";"a:1\nb:2"]  / TODO fix

/ real-world examples
roundtrip ",/(':'1+!#x)@\\:x"  / ColTim sublists
roundtrip "x@*>#'x:^/^\\(,/,\\'(1_)\\)'(x;y)"  / longest common substring
roundtrip "@[A1;&\";\"=A1;:;\",\"]"
roundtrip ",\\'(1_)\\a"
roundtrip "@[;`hello;@;1](1;2)"
roundtrip "2*+/1+{x'y}/&'\"><\"=\\:"
roundtrip "char:\"<>{}!\"\nsm:\"BETS \"!(\"T BE  \";\"  BE  \";\"T TTST\";\"TTTTTT\";\"T BE  \")\n\ng:{tokens:(#char)^char?x\n   states:\" \"sm[;]\\tokens   (+/a*0>':a:+\-/\"BE\"=\:states    / alt: -1+1^\"E B\"?states\n    +/\"T\"=&':states)}\n\n(11846;6285)~g input\n"

\d .
